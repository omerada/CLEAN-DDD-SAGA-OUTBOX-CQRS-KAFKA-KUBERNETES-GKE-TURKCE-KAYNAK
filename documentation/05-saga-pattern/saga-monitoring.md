# 🎯 SAGA Monitoring & Management

## SAGA Observability

Distributed SAGA'ları production'da güvenilir şekilde çalıştırmak için comprehensive monitoring ve management gereklidir.

### SAGA Dashboard Implementation

````java
// application/monitoring/SagaDashboardService.java
package com.example.saga.monitoring;

import com.example.saga.domain.model.SagaExecution;
import com.example.saga.domain.valueobject.*;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

/**
 * SAGA Dashboard Service
 *
 * SAGA execution'larının monitoring ve management'i için
 * comprehensive dashboard functionality sağlar.
 */
@Service
@Slf4j
public class SagaDashboardService {

    private final SagaExecutionRepository sagaExecutionRepository;
    private final SagaMetricsCollector metricsCollector;
    private final SagaAlertingService alertingService;

    /**
     * Real-time SAGA dashboard data
     */
    public SagaDashboardData getDashboardData() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime last24Hours = now.minusHours(24);
        LocalDateTime lastHour = now.minusHours(1);

        return SagaDashboardData.builder()
            .totalSagas(getTotalSagaCount())
            .activeSagas(getActiveSagaCount())
            .completedSagas(getCompletedSagaCount(last24Hours))
            .failedSagas(getFailedSagaCount(last24Hours))
            .compensatedSagas(getCompensatedSagaCount(last24Hours))
            .averageExecutionTime(getAverageExecutionTime(last24Hours))
            .successRate(getSuccessRate(last24Hours))
            .recentFailures(getRecentFailures(lastHour))
            .timeoutAlerts(getTimeoutAlerts())
            .performanceMetrics(getPerformanceMetrics(last24Hours))
            .build();
    }

    /**
     * SAGA execution timeline
     */
    public List<SagaExecutionTimeline> getSagaTimeline(SagaId sagaId) {
        SagaExecution saga = sagaExecutionRepository.findById(sagaId)
            .orElseThrow(() -> new SagaNotFoundException(sagaId));

        List<SagaExecutionTimeline> timeline = new ArrayList<>();

        // SAGA başlangıcı
        timeline.add(SagaExecutionTimeline.builder()
            .timestamp(saga.getStartedAt())
            .event("SAGA_STARTED")
            .state(SagaState.STARTED.name())
            .description("SAGA başlatıldı")
            .duration(Duration.ZERO)
            .build());

        // State transitions'ları SAGA execution log'larından al
        List<SagaStateTransition> transitions = getSagaStateTransitions(sagaId);

        for (SagaStateTransition transition : transitions) {
            timeline.add(SagaExecutionTimeline.builder()
                .timestamp(transition.getTimestamp())
                .event("STATE_TRANSITION")
                .state(transition.getToState().name())
                .description(transition.getDescription())
                .duration(transition.getDuration())
                .errorMessage(transition.getErrorMessage())
                .build());
        }

        // SAGA completion
        if (saga.getCompletedAt() != null) {
            timeline.add(SagaExecutionTimeline.builder()
                .timestamp(saga.getCompletedAt())
                .event("SAGA_COMPLETED")
                .state(saga.getState().name())
                .description("SAGA tamamlandı - " + saga.getResult().name())
                .duration(saga.getDuration())
                .errorMessage(saga.getErrorMessage())
                .build());
        }

        return timeline;
    }

    /**
     * Performance metrics
     */
    public SagaPerformanceMetrics getPerformanceMetrics(LocalDateTime since) {
        List<SagaExecution> sagas = sagaExecutionRepository.findCompletedSince(since);

        if (sagas.isEmpty()) {
            return SagaPerformanceMetrics.empty();
        }

        // Execution time statistics
        List<Duration> executionTimes = sagas.stream()
            .map(SagaExecution::getDuration)
            .sorted()
            .collect(Collectors.toList());

        Duration minTime = executionTimes.get(0);
        Duration maxTime = executionTimes.get(executionTimes.size() - 1);
        Duration avgTime = Duration.ofMillis(
            (long) executionTimes.stream()
                .mapToLong(Duration::toMillis)
                .average()
                .orElse(0)
        );

        // Percentiles
        Duration p50 = getPercentile(executionTimes, 0.5);
        Duration p95 = getPercentile(executionTimes, 0.95);
        Duration p99 = getPercentile(executionTimes, 0.99);

        // Success rate
        long totalCount = sagas.size();
        long successCount = sagas.stream()
            .filter(saga -> saga.getResult() == SagaResult.SUCCESS)
            .count();

        double successRate = (double) successCount / totalCount * 100;

        // Throughput (SAGA'lar per hour)
        long hoursSpan = Duration.between(since, LocalDateTime.now()).toHours();
        double throughput = hoursSpan > 0 ? (double) totalCount / hoursSpan : 0;

        return SagaPerformanceMetrics.builder()
            .totalExecutions(totalCount)
            .successfulExecutions(successCount)
            .successRate(successRate)
            .throughputPerHour(throughput)
            .minExecutionTime(minTime)
            .maxExecutionTime(maxTime)
            .avgExecutionTime(avgTime)
            .p50ExecutionTime(p50)\n            .p95ExecutionTime(p95)\n            .p99ExecutionTime(p99)\n            .build();\n    }\n    \n    /**\n     * Problematic SAGA'ları detect et\n     */\n    public List<SagaHealthAlert> detectProblematicSagas() {\n        List<SagaHealthAlert> alerts = new ArrayList<>();\n        LocalDateTime now = LocalDateTime.now();\n        \n        // Long running SAGA'lar\n        List<SagaExecution> longRunningSagas = sagaExecutionRepository\n            .findActiveSagasOlderThan(now.minusHours(2));\n        \n        for (SagaExecution saga : longRunningSagas) {\n            alerts.add(SagaHealthAlert.builder()\n                .sagaId(saga.getId())\n                .alertType(SagaAlertType.LONG_RUNNING)\n                .severity(AlertSeverity.WARNING)\n                .message(String.format(\n                    \"SAGA %s running for %d minutes\",\n                    saga.getId().getValue(),\n                    saga.getDuration().toMinutes()\n                ))\n                .timestamp(now)\n                .build());\n        }\n        \n        // Stuck SAGA'lar (inactive)\n        List<SagaExecution> stuckSagas = sagaExecutionRepository\n            .findInactiveSagas(Duration.ofMinutes(30));\n        \n        for (SagaExecution saga : stuckSagas) {\n            alerts.add(SagaHealthAlert.builder()\n                .sagaId(saga.getId())\n                .alertType(SagaAlertType.STUCK)\n                .severity(AlertSeverity.CRITICAL)\n                .message(String.format(\n                    \"SAGA %s has been inactive for %d minutes\",\n                    saga.getId().getValue(),\n                    Duration.between(saga.getLastActivityAt(), now).toMinutes()\n                ))\n                .timestamp(now)\n                .build());\n        }\n        \n        // High failure rate\n        LocalDateTime lastHour = now.minusHours(1);\n        long totalLastHour = sagaExecutionRepository.countStartedSince(lastHour);\n        long failedLastHour = sagaExecutionRepository.countFailedSince(lastHour);\n        \n        if (totalLastHour > 10) { // Minimum sample size\n            double failureRate = (double) failedLastHour / totalLastHour;\n            if (failureRate > 0.2) { // 20% failure rate threshold\n                alerts.add(SagaHealthAlert.builder()\n                    .alertType(SagaAlertType.HIGH_FAILURE_RATE)\n                    .severity(AlertSeverity.CRITICAL)\n                    .message(String.format(\n                        \"High failure rate detected: %.1f%% (%d/%d) in last hour\",\n                        failureRate * 100, failedLastHour, totalLastHour\n                    ))\n                    .timestamp(now)\n                    .build());\n            }\n        }\n        \n        return alerts;\n    }\n    \n    /**\n     * SAGA retry mechanism\n     */\n    public SagaRetryResult retrySaga(SagaId sagaId, String reason) {\n        log.info(\"Attempting to retry SAGA: {} - Reason: {}\", sagaId.getValue(), reason);\n        \n        try {\n            SagaExecution saga = sagaExecutionRepository.findById(sagaId)\n                .orElseThrow(() -> new SagaNotFoundException(sagaId));\n            \n            // Sadece failed SAGA'lar retry edilebilir\n            if (saga.getState() != SagaState.FAILED) {\n                return SagaRetryResult.failed(\n                    \"SAGA can only be retried from FAILED state. Current: \" + saga.getState()\n                );\n            }\n            \n            // Retry limit check\n            if (!saga.canRetry(3)) { // Max 3 retry\n                return SagaRetryResult.failed(\n                    \"SAGA has exceeded maximum retry count: \" + saga.getRetryCount()\n                );\n            }\n            \n            // Reset SAGA state for retry\n            saga.reset(reason);\n            saga.incrementRetryCount();\n            sagaExecutionRepository.save(saga);\n            \n            // Restart SAGA from beginning\n            OrderPlacedEvent originalEvent = reconstructOrderPlacedEvent(saga);\n            sagaOrchestrator.startOrderProcessingSaga(originalEvent);\n            \n            log.info(\"SAGA {} successfully queued for retry\", sagaId.getValue());\n            \n            return SagaRetryResult.successful(\"SAGA queued for retry\");\n            \n        } catch (Exception e) {\n            log.error(\"Error retrying SAGA: {}\", sagaId.getValue(), e);\n            return SagaRetryResult.failed(\"Retry failed: \" + e.getMessage());\n        }\n    }\n    \n    /**\n     * SAGA manual compensation\n     */\n    public SagaCompensationResult compensateSaga(\n        SagaId sagaId, \n        String reason, \n        String requestedBy\n    ) {\n        log.info(\"Manual compensation requested for SAGA: {} by {}\", \n                sagaId.getValue(), requestedBy);\n        \n        try {\n            SagaExecution saga = sagaExecutionRepository.findById(sagaId)\n                .orElseThrow(() -> new SagaNotFoundException(sagaId));\n            \n            // Sadece active SAGA'lar compensate edilebilir\n            if (saga.getState().isFinalState()) {\n                return SagaCompensationResult.failed(\n                    \"SAGA is already in final state: \" + saga.getState()\n                );\n            }\n            \n            // Compensation'ı başlat\n            saga.moveToState(SagaState.COMPENSATING);\n            saga.addContextData(\"manualCompensation\", true);\n            saga.addContextData(\"compensationReason\", reason);\n            saga.addContextData(\"compensationRequestedBy\", requestedBy);\n            \n            sagaExecutionRepository.save(saga);\n            \n            // Orchestrator'a compensation command gönder\n            sagaOrchestrator.startCompensation(saga, reason);\n            \n            log.info(\"Manual compensation started for SAGA: {}\", sagaId.getValue());\n            \n            return SagaCompensationResult.successful(\"Compensation started\");\n            \n        } catch (Exception e) {\n            log.error(\"Error starting manual compensation for SAGA: {}\", \n                     sagaId.getValue(), e);\n            return SagaCompensationResult.failed(\"Compensation failed: \" + e.getMessage());\n        }\n    }\n    \n    /**\n     * SAGA execution search\n     */\n    public PagedResult<SagaExecutionSummary> searchSagaExecutions(\n        SagaSearchCriteria criteria,\n        Pageable pageable\n    ) {\n        Specification<SagaExecution> spec = createSearchSpecification(criteria);\n        \n        Page<SagaExecution> sagaPage = sagaExecutionRepository.findAll(spec, pageable);\n        \n        List<SagaExecutionSummary> summaries = sagaPage.getContent().stream()\n            .map(this::createSagaExecutionSummary)\n            .collect(Collectors.toList());\n        \n        return PagedResult.<SagaExecutionSummary>builder()\n            .content(summaries)\n            .totalElements(sagaPage.getTotalElements())\n            .totalPages(sagaPage.getTotalPages())\n            .currentPage(pageable.getPageNumber())\n            .pageSize(pageable.getPageSize())\n            .build();\n    }\n    \n    private Specification<SagaExecution> createSearchSpecification(SagaSearchCriteria criteria) {\n        return (root, query, cb) -> {\n            List<Predicate> predicates = new ArrayList<>();\n            \n            if (criteria.getOrderId() != null) {\n                predicates.add(cb.equal(root.get(\"orderId\"), criteria.getOrderId()));\n            }\n            \n            if (criteria.getSagaType() != null) {\n                predicates.add(cb.equal(root.get(\"sagaType\"), criteria.getSagaType()));\n            }\n            \n            if (criteria.getState() != null) {\n                predicates.add(cb.equal(root.get(\"state\"), criteria.getState()));\n            }\n            \n            if (criteria.getResult() != null) {\n                predicates.add(cb.equal(root.get(\"result\"), criteria.getResult()));\n            }\n            \n            if (criteria.getStartedAfter() != null) {\n                predicates.add(cb.greaterThanOrEqualTo(\n                    root.get(\"startedAt\"), criteria.getStartedAfter()\n                ));\n            }\n            \n            if (criteria.getStartedBefore() != null) {\n                predicates.add(cb.lessThanOrEqualTo(\n                    root.get(\"startedAt\"), criteria.getStartedBefore()\n                ));\n            }\n            \n            return cb.and(predicates.toArray(new Predicate[0]));\n        };\n    }\n    \n    private SagaExecutionSummary createSagaExecutionSummary(SagaExecution saga) {\n        return SagaExecutionSummary.builder()\n            .sagaId(saga.getId())\n            .sagaType(saga.getSagaType())\n            .orderId(saga.getOrderId())\n            .state(saga.getState())\n            .result(saga.getResult())\n            .startedAt(saga.getStartedAt())\n            .completedAt(saga.getCompletedAt())\n            .duration(saga.getDuration())\n            .retryCount(saga.getRetryCount())\n            .errorMessage(saga.getErrorMessage())\n            .lastActivityAt(saga.getLastActivityAt())\n            .build();\n    }\n    \n    // Helper methods\n    private Duration getPercentile(List<Duration> sortedDurations, double percentile) {\n        int index = (int) Math.ceil(percentile * sortedDurations.size()) - 1;\n        return sortedDurations.get(Math.max(0, index));\n    }\n    \n    private OrderPlacedEvent reconstructOrderPlacedEvent(SagaExecution saga) {\n        // SAGA context'ten original event'i reconstruct et\n        OrderContext orderContext = (OrderContext) saga.getContextData(\"orderContext\");\n        \n        return OrderPlacedEvent.builder()\n            .orderId(saga.getOrderId().getValue())\n            .customerId(orderContext.getCustomerId().getValue())\n            .items(orderContext.getItems())\n            .totalAmount(orderContext.getTotalAmount().getAmount())\n            .currency(orderContext.getTotalAmount().getCurrency().getCurrencyCode())\n            .paymentMethod(orderContext.getPaymentMethod())\n            .shippingAddress(orderContext.getShippingAddress())\n            .occurredAt(saga.getStartedAt())\n            .build();\n    }\n}\n```\n\n## SAGA Metrics & Alerting\n\n### Metrics Collection\n\n```java\n// monitoring/SagaMetricsCollector.java\npackage com.example.saga.monitoring;\n\nimport io.micrometer.core.instrument.*;\nimport org.springframework.stereotype.Component;\n\n/**\n * SAGA Metrics Collector\n * \n * Prometheus/Grafana integration için SAGA metrics collect eder.\n */\n@Component\npublic class SagaMetricsCollector {\n    \n    private final MeterRegistry meterRegistry;\n    private final Counter sagaStartedCounter;\n    private final Counter sagaCompletedCounter;\n    private final Counter sagaFailedCounter;\n    private final Counter sagaCompensatedCounter;\n    private final Timer sagaExecutionTimer;\n    private final Gauge activeSagasGauge;\n    \n    public SagaMetricsCollector(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n        \n        // Counters\n        this.sagaStartedCounter = Counter.builder(\"saga.started.total\")\n            .description(\"Total number of SAGA executions started\")\n            .tag(\"type\", \"saga\")\n            .register(meterRegistry);\n            \n        this.sagaCompletedCounter = Counter.builder(\"saga.completed.total\")\n            .description(\"Total number of SAGA executions completed successfully\")\n            .tag(\"type\", \"saga\")\n            .register(meterRegistry);\n            \n        this.sagaFailedCounter = Counter.builder(\"saga.failed.total\")\n            .description(\"Total number of SAGA executions failed\")\n            .tag(\"type\", \"saga\")\n            .register(meterRegistry);\n            \n        this.sagaCompensatedCounter = Counter.builder(\"saga.compensated.total\")\n            .description(\"Total number of SAGA executions compensated\")\n            .tag(\"type\", \"saga\")\n            .register(meterRegistry);\n        \n        // Timer\n        this.sagaExecutionTimer = Timer.builder(\"saga.execution.duration\")\n            .description(\"SAGA execution duration\")\n            .tag(\"type\", \"saga\")\n            .register(meterRegistry);\n        \n        // Gauge\n        this.activeSagasGauge = Gauge.builder(\"saga.active.count\")\n            .description(\"Number of currently active SAGA executions\")\n            .tag(\"type\", \"saga\")\n            .register(meterRegistry, this, SagaMetricsCollector::getActiveSagaCount);\n    }\n    \n    public void recordSagaStarted(SagaType sagaType) {\n        sagaStartedCounter\n            .tag(\"saga_type\", sagaType.name())\n            .increment();\n    }\n    \n    public void recordSagaCompleted(SagaType sagaType, Duration duration) {\n        sagaCompletedCounter\n            .tag(\"saga_type\", sagaType.name())\n            .increment();\n            \n        sagaExecutionTimer\n            .tag(\"saga_type\", sagaType.name())\n            .tag(\"result\", \"success\")\n            .record(duration);\n    }\n    \n    public void recordSagaFailed(SagaType sagaType, Duration duration, String errorType) {\n        sagaFailedCounter\n            .tag(\"saga_type\", sagaType.name())\n            .tag(\"error_type\", errorType)\n            .increment();\n            \n        sagaExecutionTimer\n            .tag(\"saga_type\", sagaType.name())\n            .tag(\"result\", \"failed\")\n            .record(duration);\n    }\n    \n    public void recordSagaCompensated(SagaType sagaType, Duration duration) {\n        sagaCompensatedCounter\n            .tag(\"saga_type\", sagaType.name())\n            .increment();\n            \n        sagaExecutionTimer\n            .tag(\"saga_type\", sagaType.name())\n            .tag(\"result\", \"compensated\")\n            .record(duration);\n    }\n    \n    public void recordSagaStepDuration(\n        SagaType sagaType, \n        String stepName, \n        Duration duration,\n        boolean success\n    ) {\n        Timer.builder(\"saga.step.duration\")\n            .description(\"Individual SAGA step execution duration\")\n            .tag(\"saga_type\", sagaType.name())\n            .tag(\"step_name\", stepName)\n            .tag(\"result\", success ? \"success\" : \"failed\")\n            .register(meterRegistry)\n            .record(duration);\n    }\n    \n    private double getActiveSagaCount() {\n        // SagaExecutionRepository'den active SAGA count al\n        return sagaExecutionRepository.countActiveSagas();\n    }\n}\n```\n\n### Alerting Configuration\n\n```java\n// monitoring/SagaAlertingService.java\npackage com.example.saga.monitoring;\n\nimport org.springframework.stereotype.Service;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * SAGA Alerting Service\n * \n * Critical SAGA events için alerting sağlar.\n */\n@Service\n@Slf4j\npublic class SagaAlertingService {\n    \n    private final NotificationService notificationService;\n    private final AlertingConfiguration alertConfig;\n    \n    /**\n     * SAGA failure alert\n     */\n    public void sendSagaFailureAlert(SagaExecution saga) {\n        if (shouldAlertForFailure(saga)) {\n            AlertMessage alert = AlertMessage.builder()\n                .severity(AlertSeverity.HIGH)\n                .title(\"SAGA Execution Failed\")\n                .message(String.format(\n                    \"SAGA %s failed in state %s\\n\" +\n                    \"Order ID: %s\\n\" +\n                    \"Error: %s\\n\" +\n                    \"Duration: %s\",\n                    saga.getId().getValue(),\n                    saga.getState(),\n                    saga.getOrderId().getValue(),\n                    saga.getErrorMessage(),\n                    formatDuration(saga.getDuration())\n                ))\n                .tags(Map.of(\n                    \"saga_id\", saga.getId().getValue(),\n                    \"order_id\", saga.getOrderId().getValue(),\n                    \"saga_type\", saga.getSagaType().name()\n                ))\n                .timestamp(LocalDateTime.now())\n                .build();\n            \n            notificationService.sendAlert(alert);\n        }\n    }\n    \n    /**\n     * Long running SAGA alert\n     */\n    public void sendLongRunningSagaAlert(SagaExecution saga) {\n        Duration maxDuration = alertConfig.getMaxSagaDuration();\n        \n        if (saga.getDuration().compareTo(maxDuration) > 0) {\n            AlertMessage alert = AlertMessage.builder()\n                .severity(AlertSeverity.MEDIUM)\n                .title(\"Long Running SAGA Detected\")\n                .message(String.format(\n                    \"SAGA %s has been running for %s\\n\" +\n                    \"Current state: %s\\n\" +\n                    \"Order ID: %s\\n\" +\n                    \"Started at: %s\",\n                    saga.getId().getValue(),\n                    formatDuration(saga.getDuration()),\n                    saga.getState(),\n                    saga.getOrderId().getValue(),\n                    saga.getStartedAt()\n                ))\n                .tags(Map.of(\n                    \"saga_id\", saga.getId().getValue(),\n                    \"order_id\", saga.getOrderId().getValue(),\n                    \"duration_minutes\", String.valueOf(saga.getDuration().toMinutes())\n                ))\n                .timestamp(LocalDateTime.now())\n                .build();\n            \n            notificationService.sendAlert(alert);\n        }\n    }\n    \n    /**\n     * High failure rate alert\n     */\n    public void sendHighFailureRateAlert(\n        double failureRate, \n        long failedCount, \n        long totalCount\n    ) {\n        if (failureRate > alertConfig.getFailureRateThreshold()) {\n            AlertMessage alert = AlertMessage.builder()\n                .severity(AlertSeverity.CRITICAL)\n                .title(\"High SAGA Failure Rate\")\n                .message(String.format(\n                    \"SAGA failure rate is %.1f%% (%d/%d) in the last hour\\n\" +\n                    \"This exceeds the threshold of %.1f%%\",\n                    failureRate * 100,\n                    failedCount,\n                    totalCount,\n                    alertConfig.getFailureRateThreshold() * 100\n                ))\n                .tags(Map.of(\n                    \"failure_rate\", String.valueOf(failureRate),\n                    \"failed_count\", String.valueOf(failedCount),\n                    \"total_count\", String.valueOf(totalCount)\n                ))\n                .timestamp(LocalDateTime.now())\n                .build();\n            \n            notificationService.sendAlert(alert);\n        }\n    }\n    \n    private boolean shouldAlertForFailure(SagaExecution saga) {\n        // Skip alerts for compensated SAGA'lar (business decision)\n        if (saga.getResult() == SagaResult.COMPENSATED) {\n            return false;\n        }\n        \n        // Skip alerts for certain error types (if configured)\n        if (saga.getErrorMessage() != null) {\n            for (String ignoredError : alertConfig.getIgnoredErrorPatterns()) {\n                if (saga.getErrorMessage().contains(ignoredError)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    private String formatDuration(Duration duration) {\n        long hours = duration.toHours();\n        long minutes = duration.toMinutes() % 60;\n        long seconds = duration.getSeconds() % 60;\n        \n        return String.format(\"%dh %dm %ds\", hours, minutes, seconds);\n    }\n}\n```\n\n## SAGA Health Checks\n\n### Health Check Implementation\n\n```java\n// monitoring/SagaHealthIndicator.java\npackage com.example.saga.monitoring;\n\nimport org.springframework.boot.actuator.health.*;\nimport org.springframework.stereotype.Component;\n\n/**\n * SAGA Health Indicator for Spring Boot Actuator\n */\n@Component\npublic class SagaHealthIndicator implements HealthIndicator {\n    \n    private final SagaExecutionRepository sagaExecutionRepository;\n    private final SagaHealthConfiguration healthConfig;\n    \n    @Override\n    public Health health() {\n        try {\n            Health.Builder healthBuilder = Health.up();\n            \n            // Active SAGA count check\n            long activeSagas = sagaExecutionRepository.countActiveSagas();\n            healthBuilder.withDetail(\"activeSagas\", activeSagas);\n            \n            if (activeSagas > healthConfig.getMaxActiveSagas()) {\n                healthBuilder.down()\n                    .withDetail(\"reason\", \"Too many active SAGAs: \" + activeSagas);\n            }\n            \n            // Long running SAGAs check\n            LocalDateTime threshold = LocalDateTime.now()\n                .minus(healthConfig.getMaxSagaDuration());\n            \n            long longRunningSagas = sagaExecutionRepository\n                .countActiveSagasOlderThan(threshold);\n            \n            healthBuilder.withDetail(\"longRunningSagas\", longRunningSagas);\n            \n            if (longRunningSagas > healthConfig.getMaxLongRunningSagas()) {\n                healthBuilder.down()\n                    .withDetail(\"reason\", \"Too many long running SAGAs: \" + longRunningSagas);\n            }\n            \n            // Recent failure rate check\n            LocalDateTime lastHour = LocalDateTime.now().minusHours(1);\n            long totalRecent = sagaExecutionRepository.countStartedSince(lastHour);\n            long failedRecent = sagaExecutionRepository.countFailedSince(lastHour);\n            \n            double failureRate = totalRecent > 0 ? (double) failedRecent / totalRecent : 0;\n            \n            healthBuilder.withDetail(\"recentFailureRate\", String.format(\"%.1f%%\", failureRate * 100));\n            healthBuilder.withDetail(\"recentTotal\", totalRecent);\n            healthBuilder.withDetail(\"recentFailed\", failedRecent);\n            \n            if (totalRecent >= 10 && failureRate > healthConfig.getFailureRateThreshold()) {\n                healthBuilder.down()\n                    .withDetail(\"reason\", \"High failure rate: \" + String.format(\"%.1f%%\", failureRate * 100));\n            }\n            \n            return healthBuilder.build();\n            \n        } catch (Exception e) {\n            return Health.down()\n                .withDetail(\"error\", e.getMessage())\n                .build();\n        }\n    }\n}\n```\n\n---\n\n## 🔄 Yapılan İşlemler & Monitoring Benefits\n\n### 1. **Real-time Dashboard**\n```ascii\n┌─────────────────────────────────────────────────────────────────────┐\n│                         SAGA DASHBOARD                             │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│  📊 METRICS                   ⚠️  ALERTS                          │\n│  ┌─────────────────────┐     ┌─────────────────────────────────┐   │\n│  │ Active SAGAs: 127   │     │ 🔴 High Failure Rate (15%)    │   │\n│  │ Success Rate: 94.2% │     │ 🟡 3 Long Running SAGAs       │   │\n│  │ Avg Duration: 45s   │     │ 🟢 No Stuck SAGAs            │   │\n│  │ Throughput: 120/hr  │     │                                 │   │\n│  └─────────────────────┘     └─────────────────────────────────┘   │\n│                                                                     │\n│  📈 PERFORMANCE TRENDS        🔍 SEARCH & FILTER                  │\n│  ┌─────────────────────┐     ┌─────────────────────────────────┐   │\n│  │ P95: 2.5min        │     │ Order ID: [ORD-123____]        │   │\n│  │ P99: 4.8min        │     │ State: [Failed ▼]              │   │\n│  │ Max: 12min         │     │ Date Range: [Last 24h ▼]      │   │\n│  └─────────────────────┘     └─────────────────────────────────┘   │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n```\n\n### 2. **SAGA Execution Timeline**\n\nHer SAGA için detailed execution trace:\n- State transitions with timestamps\n- Duration breakdown per step\n- Error details and context\n- Retry attempts and reasons\n- Compensation actions taken\n\n### 3. **Proactive Health Monitoring**\n\n**Automated Detection:**\n- Long running SAGA'lar (> 2 hours)\n- Stuck SAGA'lar (inactive > 30 minutes)\n- High failure rates (> 20%)\n- Resource exhaustion (too many active SAGAs)\n\n**Alerting Channels:**\n- Slack/Teams notifications\n- Email alerts for critical issues\n- PagerDuty integration for on-call\n- Grafana dashboard alerts\n\n### 4. **Operational Actions**\n\n**Manual Operations:**\n- SAGA retry with reason tracking\n- Manual compensation trigger\n- SAGA state inspection\n- Bulk operations on stuck SAGAs\n\n**Automated Recovery:**\n- Timeout-based compensation\n- Dead letter queue processing\n- Health check based circuit breaking\n- Auto-scaling based on SAGA load\n\nBu monitoring implementation'ı ile SAGA'ları production'da güvenilir şekilde operate edebilir, proactive müdahale yapabilir ve business impact'i minimize edebiliriz! 🎯
````
