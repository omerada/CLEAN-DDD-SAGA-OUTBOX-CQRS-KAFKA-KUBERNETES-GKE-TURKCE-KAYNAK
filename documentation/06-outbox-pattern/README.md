# ğŸ“¦ BÃ¶lÃ¼m 6: Outbox Pattern\n\n## Ã–zet\n\nOutbox Pattern, mikroservislerde **atomik veri yazma ve event publishing** saÄŸlayan gÃ¼venilir messaging pattern'idir. Database transaction'larÄ± ile event publishing'i coordinate ederek **dual write problemi**ni Ã§Ã¶zer ve **exactly-once delivery** garantisi saÄŸlar.\n\n## ğŸ¯ Ã–ÄŸrenme Hedefleri\n\nBu bÃ¶lÃ¼mde ÅŸunlarÄ± Ã¶ÄŸreneceksiniz:\n\n- âœ… Outbox Pattern'in temel prensiplerini anlama\n- âœ… Dual Write Problem ve Ã§Ã¶zÃ¼mlerini kavrama\n- âœ… Transactional Outbox implementation'Ä±\n- âœ… Event Publishing strategies (Pull/Push)\n- âœ… Message Relay Service tasarÄ±mÄ±\n- âœ… Exactly-once delivery garantilerini saÄŸlama\n- âœ… Performance optimization teknikleri\n- âœ… Monitoring ve troubleshooting\n\n## ğŸ“‹ Ã–n KoÅŸullar\n\n- Domain Driven Design patterns bilgisi\n- SAGA Pattern implementation deneyimi\n- Database transactions ve ACID properties\n- Event-driven architecture fundamentals\n- Spring Boot ve JPA/Hibernate\n- Apache Kafka knowledge\n\n---\n\n## ğŸ”„ Dual Write Problem\n\n### Problem Definition\n\nMikroservislerde en yaygÄ±n anti-pattern'lerden biri **dual write**'tÄ±r:\n\n`java\n// âŒ YANLIÅ YAKLAÅIM - Dual Write Problem\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private EventPublisher eventPublisher;\n    \n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        // 1. Database'e yaz\n        Order order = Order.create(command);\n        orderRepository.save(order); // âœ… Transaction iÃ§inde\n        \n        // 2. Event publish et\n        OrderCreatedEvent event = OrderCreatedEvent.from(order);\n        eventPublisher.publish(event); // âŒ Transaction dÄ±ÅŸÄ±nda!\n        \n        // Problem: Database commit olur ama event publish baÅŸarÄ±sÄ±z olabilir\n        // SonuÃ§: Inconsistent state!\n    }\n}\n`\n\n### Failure Scenarios\n\n`ascii\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                      DUAL WRITE FAILURE SCENARIOS                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                     â”‚\nâ”‚  Scenario 1: Database Success + Event Failure                      â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚   Database Write    â”‚    â”‚        Event Publishing         â”‚   â”‚\nâ”‚  â”‚        âœ…           â”‚ â†’  â”‚             âŒ                  â”‚   â”‚\nâ”‚  â”‚  Order saved to DB  â”‚    â”‚   Kafka broker unreachable     â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚  Result: Order exists but no downstream services notified          â”‚\nâ”‚                                                                     â”‚\nâ”‚  Scenario 2: Database Failure + Event Success                      â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚   Database Write    â”‚    â”‚        Event Publishing         â”‚   â”‚\nâ”‚  â”‚        âŒ           â”‚ â†’  â”‚             âœ…                  â”‚   â”‚\nâ”‚  â”‚  Constraint violationâ”‚    â”‚   Event published to Kafka     â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚  Result: Downstream services process non-existent order            â”‚\nâ”‚                                                                     â”‚\nâ”‚  Scenario 3: Partial Network Failure                               â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚   Database Write    â”‚    â”‚        Event Publishing         â”‚   â”‚\nâ”‚  â”‚        âœ…           â”‚ â†’  â”‚             âš ï¸                  â”‚   â”‚\nâ”‚  â”‚     Committed       â”‚    â”‚      Timeout/Retrying           â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚  Result: Unknown state - event may be duplicated                   â”‚\nâ”‚                                                                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n`\n\n---\n\n## ğŸ“¦ Outbox Pattern Solution\n\n### Core Concept\n\nOutbox Pattern, **database transaction iÃ§inde event'leri bir outbox table'a yazar** ve sonra **ayrÄ± bir process** bu event'leri message broker'a publish eder.\n\n`ascii\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                         OUTBOX PATTERN FLOW                        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                     â”‚\nâ”‚  Step 1: Single Database Transaction                                â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚                    Database Transaction                     â”‚   â”‚\nâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚\nâ”‚  â”‚  â”‚  Business Data  â”‚    â”‚         Outbox Table            â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚                 â”‚    â”‚                                 â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚   Order Table   â”‚    â”‚   Event ID: uuid-123           â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚   Event Type: OrderCreated     â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚   â”‚Order-123â”‚   â”‚    â”‚   Payload: {orderId: 123...}   â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚   â”‚Status:  â”‚   â”‚    â”‚   Status: PENDING              â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚   â”‚CREATED  â”‚   â”‚    â”‚   Created: 2024-01-15 10:00    â”‚ â”‚   â”‚\nâ”‚  â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚                                 â”‚ â”‚   â”‚\nâ”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚                                                                     â”‚\nâ”‚  Step 2: Message Relay Service                                     â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚               Background Process                            â”‚   â”‚\nâ”‚  â”‚                                                             â”‚   â”‚\nâ”‚  â”‚  1. Poll outbox table for PENDING events                   â”‚   â”‚\nâ”‚  â”‚  2. Publish events to Kafka                                â”‚   â”‚\nâ”‚  â”‚  3. Mark events as PUBLISHED                               â”‚   â”‚\nâ”‚  â”‚  4. Optionally archive old events                          â”‚   â”‚\nâ”‚  â”‚                                                             â”‚   â”‚\nâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚\nâ”‚  â”‚  â”‚    Poll     â”‚ â†’  â”‚   Publish   â”‚ â†’  â”‚  Mark Done  â”‚   â”‚   â”‚\nâ”‚  â”‚  â”‚   Outbox    â”‚    â”‚  to Kafka   â”‚    â”‚   Update    â”‚   â”‚   â”‚\nâ”‚  â”‚  â”‚    Table    â”‚    â”‚   Broker    â”‚    â”‚   Status    â”‚   â”‚   â”‚\nâ”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚                                                                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n`\n\n### Benefits\n\nâœ… **Atomicity**: Database write ve event storage tek transaction'da \nâœ… **Consistency**: Event'ler kaybolmaz, duplicate olmaz \nâœ… **Durability**: Event'ler database'de persist edilir \nâœ… **Reliability**: Message relay failure'Ä±nda retry mekanizmasÄ± \nâœ… **Ordering**: Event'lerin doÄŸru sÄ±rada iÅŸlenmesi \nâœ… **Monitoring**: Event publishing sÃ¼recinin izlenebilirliÄŸi \n\n---\n\n## ğŸ—ï¸ Outbox Implementation\n\n### Outbox Entity Design\n\n`java\n// domain/model/OutboxEvent.java\npackage com.example.outbox.domain.model;\n\nimport jakarta.persistence.*;\nimport lombok.*;\nimport java.time.LocalDateTime;\nimport java.util.UUID;\n\n/**\n * Outbox Event Entity\n * \n * Database transaction iÃ§inde event'leri store eden entity.\n * Message relay service tarafÄ±ndan poll edilir ve Kafka'ya publish edilir.\n */\n@Entity\n@Table(name = \"outbox_events\", indexes = {\n    @Index(name = \"idx_outbox_status_created\", columnList = \"status, created_at\"),\n    @Index(name = \"idx_outbox_aggregate_id\", columnList = \"aggregate_id\"),\n    @Index(name = \"idx_outbox_event_type\", columnList = \"event_type\")\n})\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class OutboxEvent {\n    \n    @Id\n    @Column(name = \"event_id\", updatable = false)\n    private String eventId;\n    \n    @Column(name = \"aggregate_id\", nullable = false)\n    private String aggregateId;\n    \n    @Column(name = \"aggregate_type\", nullable = false)\n    private String aggregateType;\n    \n    @Column(name = \"event_type\", nullable = false)\n    private String eventType;\n    \n    @Lob\n    @Column(name = \"event_payload\", nullable = false)\n    private String eventPayload;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\", nullable = false)\n    private OutboxEventStatus status;\n    \n    @Column(name = \"created_at\", nullable = false)\n    private LocalDateTime createdAt;\n    \n    @Column(name = \"published_at\")\n    private LocalDateTime publishedAt;\n    \n    @Column(name = \"retry_count\", nullable = false)\n    private Integer retryCount;\n    \n    @Column(name = \"last_retry_at\")\n    private LocalDateTime lastRetryAt;\n    \n    @Column(name = \"error_message\")\n    private String errorMessage;\n    \n    @Version\n    @Column(name = \"version\")\n    private Long version;\n    \n    /**\n     * Factory method for creating new outbox event\n     */\n    public static OutboxEvent create(\n        String aggregateId,\n        String aggregateType,\n        String eventType,\n        String eventPayload\n    ) {\n        return OutboxEvent.builder()\n            .eventId(UUID.randomUUID().toString())\n            .aggregateId(aggregateId)\n            .aggregateType(aggregateType)\n            .eventType(eventType)\n            .eventPayload(eventPayload)\n            .status(OutboxEventStatus.PENDING)\n            .createdAt(LocalDateTime.now())\n            .retryCount(0)\n            .build();\n    }\n    \n    /**\n     * Mark event as successfully published\n     */\n    public void markAsPublished() {\n        this.status = OutboxEventStatus.PUBLISHED;\n        this.publishedAt = LocalDateTime.now();\n    }\n    \n    /**\n     * Mark event as failed with error details\n     */\n    public void markAsFailed(String errorMessage) {\n        this.status = OutboxEventStatus.FAILED;\n        this.errorMessage = errorMessage;\n        this.lastRetryAt = LocalDateTime.now();\n        this.retryCount++;\n    }\n    \n    /**\n     * Reset for retry\n     */\n    public void resetForRetry() {\n        this.status = OutboxEventStatus.PENDING;\n        this.errorMessage = null;\n    }\n    \n    /**\n     * Check if event can be retried\n     */\n    public boolean canRetry(int maxRetries) {\n        return this.retryCount < maxRetries && \n               this.status == OutboxEventStatus.FAILED;\n    }\n}\n\n/**\n * Outbox Event Status Enum\n */\nenum OutboxEventStatus {\n    PENDING,     // Event created, waiting to be published\n    PUBLISHED,   // Event successfully published to message broker\n    FAILED       // Event publishing failed, may be retried\n}\n`\n\n### Outbox Service Implementation\n\n`java\n// application/service/OutboxService.java\npackage com.example.outbox.application.service;\n\nimport com.example.outbox.domain.model.OutboxEvent;\nimport com.example.outbox.infrastructure.repository.OutboxEventRepository;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * Outbox Service\n * \n * Business logic iÃ§inde event'leri outbox'a kaydetmek iÃ§in kullanÄ±lÄ±r.\n * Transaction iÃ§inde Ã§alÄ±ÅŸÄ±r ve dual write problem'ini Ã§Ã¶zer.\n */\n@Service\n@Slf4j\npublic class OutboxService {\n    \n    private final OutboxEventRepository outboxEventRepository;\n    private final ObjectMapper objectMapper;\n    \n    public OutboxService(\n        OutboxEventRepository outboxEventRepository,\n        ObjectMapper objectMapper\n    ) {\n        this.outboxEventRepository = outboxEventRepository;\n        this.objectMapper = objectMapper;\n    }\n    \n    /**\n     * Save domain event to outbox table\n     * \n     * Bu method business transaction iÃ§inde Ã§aÄŸrÄ±lÄ±r.\n     * Event JSON olarak serialize edilir ve outbox table'a kaydedilir.\n     */\n    @Transactional\n    public void saveEvent(\n        String aggregateId,\n        String aggregateType,\n        Object domainEvent\n    ) {\n        try {\n            String eventType = domainEvent.getClass().getSimpleName();\n            String eventPayload = objectMapper.writeValueAsString(domainEvent);\n            \n            OutboxEvent outboxEvent = OutboxEvent.create(\n                aggregateId,\n                aggregateType,\n                eventType,\n                eventPayload\n            );\n            \n            outboxEventRepository.save(outboxEvent);\n            \n            log.debug(\"Saved event to outbox: {} for aggregate: {}\", \n                     eventType, aggregateId);\n            \n        } catch (JsonProcessingException e) {\n            log.error(\"Failed to serialize event: {}\", domainEvent.getClass(), e);\n            throw new OutboxSerializationException(\n                \"Failed to serialize domain event\", e\n            );\n        }\n    }\n    \n    /**\n     * Save multiple events in single transaction\n     */\n    @Transactional\n    public void saveEvents(\n        String aggregateId,\n        String aggregateType,\n        Object... domainEvents\n    ) {\n        for (Object event : domainEvents) {\n            saveEvent(aggregateId, aggregateType, event);\n        }\n        \n        log.debug(\"Saved {} events to outbox for aggregate: {}\", \n                 domainEvents.length, aggregateId);\n    }\n    \n    /**\n     * Get pending events for publishing\n     */\n    @Transactional(readOnly = true)\n    public List<OutboxEvent> getPendingEvents(int limit) {\n        return outboxEventRepository.findPendingEventsForProcessing(limit);\n    }\n    \n    /**\n     * Mark event as published\n     */\n    @Transactional\n    public void markEventAsPublished(String eventId) {\n        OutboxEvent event = outboxEventRepository.findById(eventId)\n            .orElseThrow(() -> new OutboxEventNotFoundException(eventId));\n        \n        event.markAsPublished();\n        outboxEventRepository.save(event);\n        \n        log.debug(\"Marked event as published: {}\", eventId);\n    }\n    \n    /**\n     * Mark event as failed\n     */\n    @Transactional\n    public void markEventAsFailed(String eventId, String errorMessage) {\n        OutboxEvent event = outboxEventRepository.findById(eventId)\n            .orElseThrow(() -> new OutboxEventNotFoundException(eventId));\n        \n        event.markAsFailed(errorMessage);\n        outboxEventRepository.save(event);\n        \n        log.warn(\"Marked event as failed: {} - {}\", eventId, errorMessage);\n    }\n    \n    /**\n     * Reset failed events for retry\n     */\n    @Transactional\n    public int resetFailedEventsForRetry(int maxRetries, Duration retryDelay) {\n        LocalDateTime retryThreshold = LocalDateTime.now().minus(retryDelay);\n        \n        List<OutboxEvent> failedEvents = outboxEventRepository\n            .findFailedEventsForRetry(maxRetries, retryThreshold);\n        \n        for (OutboxEvent event : failedEvents) {\n            event.resetForRetry();\n        }\n        \n        outboxEventRepository.saveAll(failedEvents);\n        \n        log.info(\"Reset {} failed events for retry\", failedEvents.size());\n        return failedEvents.size();\n    }\n    \n    /**\n     * Archive old published events\n     */\n    @Transactional\n    public int archiveOldEvents(Duration archiveAfter) {\n        LocalDateTime archiveThreshold = LocalDateTime.now().minus(archiveAfter);\n        \n        int archivedCount = outboxEventRepository\n            .deletePublishedEventsBefore(archiveThreshold);\n        \n        log.info(\"Archived {} old events\", archivedCount);\n        return archivedCount;\n    }\n}\n`\n\n### Integration with Business Logic\n\n`java\n// application/service/OrderService.java\npackage com.example.order.application.service;\n\nimport com.example.outbox.application.service.OutboxService;\nimport com.example.order.domain.event.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * Order Service with Outbox Pattern Integration\n * \n * Business logic iÃ§inde outbox pattern kullanarak reliable event publishing.\n */\n@Service\n@Slf4j\npublic class OrderService {\n    \n    private final OrderRepository orderRepository;\n    private final OutboxService outboxService;\n    private final OrderDomainService orderDomainService;\n    \n    /**\n     * Create order with reliable event publishing\n     */\n    @Transactional\n    public OrderId createOrder(CreateOrderCommand command) {\n        log.info(\"Creating order for customer: {}\", command.getCustomerId());\n        \n        try {\n            // 1. Business logic execution\n            Order order = orderDomainService.createOrder(command);\n            orderRepository.save(order);\n            \n            // 2. Event'leri outbox'a kaydet - AYNI TRANSACTION Ä°Ã‡Ä°NDE!\n            OrderCreatedEvent orderCreatedEvent = OrderCreatedEvent.builder()\n                .orderId(order.getId().getValue())\n                .customerId(order.getCustomerId().getValue())\n                .items(order.getItems().stream()\n                    .map(item -> OrderEventItem.builder()\n                        .productId(item.getProductId().getValue())\n                        .quantity(item.getQuantity())\n                        .unitPrice(item.getUnitPrice().getAmount())\n                        .build())\n                    .collect(Collectors.toList()))\n                .totalAmount(order.getTotalAmount().getAmount())\n                .currency(order.getTotalAmount().getCurrency().getCurrencyCode())\n                .status(order.getStatus().name())\n                .shippingAddress(AddressDto.from(order.getShippingAddress()))\n                .paymentMethod(order.getPaymentMethod())\n                .occurredAt(LocalDateTime.now())\n                .build();\n            \n            // Outbox'a event kaydet\n            outboxService.saveEvent(\n                order.getId().getValue(),\n                \"Order\",\n                orderCreatedEvent\n            );\n            \n            log.info(\"Order created successfully: {}\", order.getId().getValue());\n            return order.getId();\n            \n        } catch (Exception e) {\n            log.error(\"Failed to create order: {}\", command, e);\n            throw new OrderCreationException(\"Order creation failed\", e);\n        }\n    }\n    \n    /**\n     * Update order status with event publishing\n     */\n    @Transactional\n    public void updateOrderStatus(\n        OrderId orderId, \n        OrderStatus newStatus, \n        String reason\n    ) {\n        log.info(\"Updating order status: {} -> {}\", orderId.getValue(), newStatus);\n        \n        Order order = orderRepository.findById(orderId)\n            .orElseThrow(() -> new OrderNotFoundException(orderId));\n        \n        OrderStatus previousStatus = order.getStatus();\n        \n        // Business logic\n        order.updateStatus(newStatus, reason);\n        orderRepository.save(order);\n        \n        // Event to outbox\n        OrderStatusUpdatedEvent statusUpdatedEvent = OrderStatusUpdatedEvent.builder()\n            .orderId(order.getId().getValue())\n            .previousStatus(previousStatus.name())\n            .newStatus(newStatus.name())\n            .reason(reason)\n            .updatedBy(getCurrentUserId()) // Security context'ten\n            .occurredAt(LocalDateTime.now())\n            .build();\n        \n        outboxService.saveEvent(\n            order.getId().getValue(),\n            \"Order\",\n            statusUpdatedEvent\n        );\n        \n        log.info(\"Order status updated: {}\", orderId.getValue());\n    }\n    \n    /**\n     * Cancel order with compensation events\n     */\n    @Transactional\n    public void cancelOrder(OrderId orderId, String reason) {\n        log.info(\"Canceling order: {} - Reason: {}\", orderId.getValue(), reason);\n        \n        Order order = orderRepository.findById(orderId)\n            .orElseThrow(() -> new OrderNotFoundException(orderId));\n        \n        // Validation\n        if (!order.canBeCanceled()) {\n            throw new OrderCancellationException(\n                \"Order cannot be canceled in current status: \" + order.getStatus()\n            );\n        }\n        \n        // Business logic\n        order.cancel(reason);\n        orderRepository.save(order);\n        \n        // Multiple events for different downstream services\n        OrderCanceledEvent orderCanceledEvent = OrderCanceledEvent.builder()\n            .orderId(order.getId().getValue())\n            .customerId(order.getCustomerId().getValue())\n            .reason(reason)\n            .canceledBy(getCurrentUserId())\n            .originalAmount(order.getTotalAmount().getAmount())\n            .currency(order.getTotalAmount().getCurrency().getCurrencyCode())\n            .occurredAt(LocalDateTime.now())\n            .build();\n        \n        PaymentRefundRequestedEvent refundEvent = PaymentRefundRequestedEvent.builder()\n            .orderId(order.getId().getValue())\n            .paymentId(order.getPaymentId().getValue())\n            .refundAmount(order.getTotalAmount().getAmount())\n            .currency(order.getTotalAmount().getCurrency().getCurrencyCode())\n            .reason(\"Order cancellation: \" + reason)\n            .requestedBy(getCurrentUserId())\n            .occurredAt(LocalDateTime.now())\n            .build();\n        \n        InventoryReleaseRequestedEvent inventoryReleaseEvent = \n            InventoryReleaseRequestedEvent.builder()\n                .orderId(order.getId().getValue())\n                .reservationId(order.getInventoryReservationId().getValue())\n                .items(order.getItems().stream()\n                    .map(item -> InventoryReleaseItem.builder()\n                        .productId(item.getProductId().getValue())\n                        .quantity(item.getQuantity())\n                        .build())\n                    .collect(Collectors.toList()))\n                .reason(\"Order cancellation\")\n                .occurredAt(LocalDateTime.now())\n                .build();\n        \n        // Save all events to outbox\n        outboxService.saveEvents(\n            order.getId().getValue(),\n            \"Order\",\n            orderCanceledEvent,\n            refundEvent,\n            inventoryReleaseEvent\n        );\n        \n        log.info(\"Order canceled with events saved to outbox: {}\", orderId.getValue());\n    }\n    \n    private String getCurrentUserId() {\n        // Spring Security context'ten current user'Ä± al\n        return SecurityContextHolder.getContext()\n            .getAuthentication()\n            .getName();\n    }\n}\n`\n\nBu implementation ile artÄ±k **atomik veri yazma ve event publishing** garantisi saÄŸlÄ±yoruz! Database transaction iÃ§inde hem business data hem de event'ler kaydediliyor. ğŸ¯\n\n**Sonraki adÄ±m:** Message Relay Service implementation'Ä±! ğŸš€
