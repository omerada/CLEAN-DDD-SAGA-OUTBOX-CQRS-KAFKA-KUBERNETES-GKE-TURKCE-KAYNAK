# 📦 Bölüm 6: Outbox Pattern\n\n## Özet\n\nOutbox Pattern, mikroservislerde **atomik veri yazma ve event publishing** sağlayan güvenilir messaging pattern'idir. Database transaction'ları ile event publishing'i coordinate ederek **dual write problemi**ni çözer ve **exactly-once delivery** garantisi sağlar.\n\n## 🎯 Öğrenme Hedefleri\n\nBu bölümde şunları öğreneceksiniz:\n\n- ✅ Outbox Pattern'in temel prensiplerini anlama\n- ✅ Dual Write Problem ve çözümlerini kavrama\n- ✅ Transactional Outbox implementation'ı\n- ✅ Event Publishing strategies (Pull/Push)\n- ✅ Message Relay Service tasarımı\n- ✅ Exactly-once delivery garantilerini sağlama\n- ✅ Performance optimization teknikleri\n- ✅ Monitoring ve troubleshooting\n\n## 📋 Ön Koşullar\n\n- Domain Driven Design patterns bilgisi\n- SAGA Pattern implementation deneyimi\n- Database transactions ve ACID properties\n- Event-driven architecture fundamentals\n- Spring Boot ve JPA/Hibernate\n- Apache Kafka knowledge\n\n---\n\n## 🔄 Dual Write Problem\n\n### Problem Definition\n\nMikroservislerde en yaygın anti-pattern'lerden biri **dual write**'tır:\n\n`java\n// ❌ YANLIŞ YAKLAŞIM - Dual Write Problem\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private EventPublisher eventPublisher;\n    \n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        // 1. Database'e yaz\n        Order order = Order.create(command);\n        orderRepository.save(order); // ✅ Transaction içinde\n        \n        // 2. Event publish et\n        OrderCreatedEvent event = OrderCreatedEvent.from(order);\n        eventPublisher.publish(event); // ❌ Transaction dışında!\n        \n        // Problem: Database commit olur ama event publish başarısız olabilir\n        // Sonuç: Inconsistent state!\n    }\n}\n`\n\n### Failure Scenarios\n\n`ascii\n┌─────────────────────────────────────────────────────────────────────┐\n│                      DUAL WRITE FAILURE SCENARIOS                 │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│  Scenario 1: Database Success + Event Failure                      │\n│  ┌─────────────────────┐    ┌─────────────────────────────────┐   │\n│  │   Database Write    │    │        Event Publishing         │   │\n│  │        ✅           │ →  │             ❌                  │   │\n│  │  Order saved to DB  │    │   Kafka broker unreachable     │   │\n│  └─────────────────────┘    └─────────────────────────────────┘   │\n│  Result: Order exists but no downstream services notified          │\n│                                                                     │\n│  Scenario 2: Database Failure + Event Success                      │\n│  ┌─────────────────────┐    ┌─────────────────────────────────┐   │\n│  │   Database Write    │    │        Event Publishing         │   │\n│  │        ❌           │ →  │             ✅                  │   │\n│  │  Constraint violation│    │   Event published to Kafka     │   │\n│  └─────────────────────┘    └─────────────────────────────────┘   │\n│  Result: Downstream services process non-existent order            │\n│                                                                     │\n│  Scenario 3: Partial Network Failure                               │\n│  ┌─────────────────────┐    ┌─────────────────────────────────┐   │\n│  │   Database Write    │    │        Event Publishing         │   │\n│  │        ✅           │ →  │             ⚠️                  │   │\n│  │     Committed       │    │      Timeout/Retrying           │   │\n│  └─────────────────────┘    └─────────────────────────────────┘   │\n│  Result: Unknown state - event may be duplicated                   │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n`\n\n---\n\n## 📦 Outbox Pattern Solution\n\n### Core Concept\n\nOutbox Pattern, **database transaction içinde event'leri bir outbox table'a yazar** ve sonra **ayrı bir process** bu event'leri message broker'a publish eder.\n\n`ascii\n┌─────────────────────────────────────────────────────────────────────┐\n│                         OUTBOX PATTERN FLOW                        │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│  Step 1: Single Database Transaction                                │\n│  ┌─────────────────────────────────────────────────────────────┐   │\n│  │                    Database Transaction                     │   │\n│  │  ┌─────────────────┐    ┌─────────────────────────────────┐ │   │\n│  │  │  Business Data  │    │         Outbox Table            │ │   │\n│  │  │                 │    │                                 │ │   │\n│  │  │   Order Table   │    │   Event ID: uuid-123           │ │   │\n│  │  │   ┌─────────┐   │    │   Event Type: OrderCreated     │ │   │\n│  │  │   │Order-123│   │    │   Payload: {orderId: 123...}   │ │   │\n│  │  │   │Status:  │   │    │   Status: PENDING              │ │   │\n│  │  │   │CREATED  │   │    │   Created: 2024-01-15 10:00    │ │   │\n│  │  │   └─────────┘   │    │                                 │ │   │\n│  │  └─────────────────┘    └─────────────────────────────────┘ │   │\n│  └─────────────────────────────────────────────────────────────┘   │\n│                                                                     │\n│  Step 2: Message Relay Service                                     │\n│  ┌─────────────────────────────────────────────────────────────┐   │\n│  │               Background Process                            │   │\n│  │                                                             │   │\n│  │  1. Poll outbox table for PENDING events                   │   │\n│  │  2. Publish events to Kafka                                │   │\n│  │  3. Mark events as PUBLISHED                               │   │\n│  │  4. Optionally archive old events                          │   │\n│  │                                                             │   │\n│  │  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐   │   │\n│  │  │    Poll     │ →  │   Publish   │ →  │  Mark Done  │   │   │\n│  │  │   Outbox    │    │  to Kafka   │    │   Update    │   │   │\n│  │  │    Table    │    │   Broker    │    │   Status    │   │   │\n│  │  └─────────────┘    └─────────────┘    └─────────────┘   │   │\n│  └─────────────────────────────────────────────────────────────┘   │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n`\n\n### Benefits\n\n✅ **Atomicity**: Database write ve event storage tek transaction'da \n✅ **Consistency**: Event'ler kaybolmaz, duplicate olmaz \n✅ **Durability**: Event'ler database'de persist edilir \n✅ **Reliability**: Message relay failure'ında retry mekanizması \n✅ **Ordering**: Event'lerin doğru sırada işlenmesi \n✅ **Monitoring**: Event publishing sürecinin izlenebilirliği \n\n---\n\n## 🏗️ Outbox Implementation\n\n### Outbox Entity Design\n\n`java\n// domain/model/OutboxEvent.java\npackage com.example.outbox.domain.model;\n\nimport jakarta.persistence.*;\nimport lombok.*;\nimport java.time.LocalDateTime;\nimport java.util.UUID;\n\n/**\n * Outbox Event Entity\n * \n * Database transaction içinde event'leri store eden entity.\n * Message relay service tarafından poll edilir ve Kafka'ya publish edilir.\n */\n@Entity\n@Table(name = \"outbox_events\", indexes = {\n    @Index(name = \"idx_outbox_status_created\", columnList = \"status, created_at\"),\n    @Index(name = \"idx_outbox_aggregate_id\", columnList = \"aggregate_id\"),\n    @Index(name = \"idx_outbox_event_type\", columnList = \"event_type\")\n})\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class OutboxEvent {\n    \n    @Id\n    @Column(name = \"event_id\", updatable = false)\n    private String eventId;\n    \n    @Column(name = \"aggregate_id\", nullable = false)\n    private String aggregateId;\n    \n    @Column(name = \"aggregate_type\", nullable = false)\n    private String aggregateType;\n    \n    @Column(name = \"event_type\", nullable = false)\n    private String eventType;\n    \n    @Lob\n    @Column(name = \"event_payload\", nullable = false)\n    private String eventPayload;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\", nullable = false)\n    private OutboxEventStatus status;\n    \n    @Column(name = \"created_at\", nullable = false)\n    private LocalDateTime createdAt;\n    \n    @Column(name = \"published_at\")\n    private LocalDateTime publishedAt;\n    \n    @Column(name = \"retry_count\", nullable = false)\n    private Integer retryCount;\n    \n    @Column(name = \"last_retry_at\")\n    private LocalDateTime lastRetryAt;\n    \n    @Column(name = \"error_message\")\n    private String errorMessage;\n    \n    @Version\n    @Column(name = \"version\")\n    private Long version;\n    \n    /**\n     * Factory method for creating new outbox event\n     */\n    public static OutboxEvent create(\n        String aggregateId,\n        String aggregateType,\n        String eventType,\n        String eventPayload\n    ) {\n        return OutboxEvent.builder()\n            .eventId(UUID.randomUUID().toString())\n            .aggregateId(aggregateId)\n            .aggregateType(aggregateType)\n            .eventType(eventType)\n            .eventPayload(eventPayload)\n            .status(OutboxEventStatus.PENDING)\n            .createdAt(LocalDateTime.now())\n            .retryCount(0)\n            .build();\n    }\n    \n    /**\n     * Mark event as successfully published\n     */\n    public void markAsPublished() {\n        this.status = OutboxEventStatus.PUBLISHED;\n        this.publishedAt = LocalDateTime.now();\n    }\n    \n    /**\n     * Mark event as failed with error details\n     */\n    public void markAsFailed(String errorMessage) {\n        this.status = OutboxEventStatus.FAILED;\n        this.errorMessage = errorMessage;\n        this.lastRetryAt = LocalDateTime.now();\n        this.retryCount++;\n    }\n    \n    /**\n     * Reset for retry\n     */\n    public void resetForRetry() {\n        this.status = OutboxEventStatus.PENDING;\n        this.errorMessage = null;\n    }\n    \n    /**\n     * Check if event can be retried\n     */\n    public boolean canRetry(int maxRetries) {\n        return this.retryCount < maxRetries && \n               this.status == OutboxEventStatus.FAILED;\n    }\n}\n\n/**\n * Outbox Event Status Enum\n */\nenum OutboxEventStatus {\n    PENDING,     // Event created, waiting to be published\n    PUBLISHED,   // Event successfully published to message broker\n    FAILED       // Event publishing failed, may be retried\n}\n`\n\n### Outbox Service Implementation\n\n`java\n// application/service/OutboxService.java\npackage com.example.outbox.application.service;\n\nimport com.example.outbox.domain.model.OutboxEvent;\nimport com.example.outbox.infrastructure.repository.OutboxEventRepository;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * Outbox Service\n * \n * Business logic içinde event'leri outbox'a kaydetmek için kullanılır.\n * Transaction içinde çalışır ve dual write problem'ini çözer.\n */\n@Service\n@Slf4j\npublic class OutboxService {\n    \n    private final OutboxEventRepository outboxEventRepository;\n    private final ObjectMapper objectMapper;\n    \n    public OutboxService(\n        OutboxEventRepository outboxEventRepository,\n        ObjectMapper objectMapper\n    ) {\n        this.outboxEventRepository = outboxEventRepository;\n        this.objectMapper = objectMapper;\n    }\n    \n    /**\n     * Save domain event to outbox table\n     * \n     * Bu method business transaction içinde çağrılır.\n     * Event JSON olarak serialize edilir ve outbox table'a kaydedilir.\n     */\n    @Transactional\n    public void saveEvent(\n        String aggregateId,\n        String aggregateType,\n        Object domainEvent\n    ) {\n        try {\n            String eventType = domainEvent.getClass().getSimpleName();\n            String eventPayload = objectMapper.writeValueAsString(domainEvent);\n            \n            OutboxEvent outboxEvent = OutboxEvent.create(\n                aggregateId,\n                aggregateType,\n                eventType,\n                eventPayload\n            );\n            \n            outboxEventRepository.save(outboxEvent);\n            \n            log.debug(\"Saved event to outbox: {} for aggregate: {}\", \n                     eventType, aggregateId);\n            \n        } catch (JsonProcessingException e) {\n            log.error(\"Failed to serialize event: {}\", domainEvent.getClass(), e);\n            throw new OutboxSerializationException(\n                \"Failed to serialize domain event\", e\n            );\n        }\n    }\n    \n    /**\n     * Save multiple events in single transaction\n     */\n    @Transactional\n    public void saveEvents(\n        String aggregateId,\n        String aggregateType,\n        Object... domainEvents\n    ) {\n        for (Object event : domainEvents) {\n            saveEvent(aggregateId, aggregateType, event);\n        }\n        \n        log.debug(\"Saved {} events to outbox for aggregate: {}\", \n                 domainEvents.length, aggregateId);\n    }\n    \n    /**\n     * Get pending events for publishing\n     */\n    @Transactional(readOnly = true)\n    public List<OutboxEvent> getPendingEvents(int limit) {\n        return outboxEventRepository.findPendingEventsForProcessing(limit);\n    }\n    \n    /**\n     * Mark event as published\n     */\n    @Transactional\n    public void markEventAsPublished(String eventId) {\n        OutboxEvent event = outboxEventRepository.findById(eventId)\n            .orElseThrow(() -> new OutboxEventNotFoundException(eventId));\n        \n        event.markAsPublished();\n        outboxEventRepository.save(event);\n        \n        log.debug(\"Marked event as published: {}\", eventId);\n    }\n    \n    /**\n     * Mark event as failed\n     */\n    @Transactional\n    public void markEventAsFailed(String eventId, String errorMessage) {\n        OutboxEvent event = outboxEventRepository.findById(eventId)\n            .orElseThrow(() -> new OutboxEventNotFoundException(eventId));\n        \n        event.markAsFailed(errorMessage);\n        outboxEventRepository.save(event);\n        \n        log.warn(\"Marked event as failed: {} - {}\", eventId, errorMessage);\n    }\n    \n    /**\n     * Reset failed events for retry\n     */\n    @Transactional\n    public int resetFailedEventsForRetry(int maxRetries, Duration retryDelay) {\n        LocalDateTime retryThreshold = LocalDateTime.now().minus(retryDelay);\n        \n        List<OutboxEvent> failedEvents = outboxEventRepository\n            .findFailedEventsForRetry(maxRetries, retryThreshold);\n        \n        for (OutboxEvent event : failedEvents) {\n            event.resetForRetry();\n        }\n        \n        outboxEventRepository.saveAll(failedEvents);\n        \n        log.info(\"Reset {} failed events for retry\", failedEvents.size());\n        return failedEvents.size();\n    }\n    \n    /**\n     * Archive old published events\n     */\n    @Transactional\n    public int archiveOldEvents(Duration archiveAfter) {\n        LocalDateTime archiveThreshold = LocalDateTime.now().minus(archiveAfter);\n        \n        int archivedCount = outboxEventRepository\n            .deletePublishedEventsBefore(archiveThreshold);\n        \n        log.info(\"Archived {} old events\", archivedCount);\n        return archivedCount;\n    }\n}\n`\n\n### Integration with Business Logic\n\n`java\n// application/service/OrderService.java\npackage com.example.order.application.service;\n\nimport com.example.outbox.application.service.OutboxService;\nimport com.example.order.domain.event.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * Order Service with Outbox Pattern Integration\n * \n * Business logic içinde outbox pattern kullanarak reliable event publishing.\n */\n@Service\n@Slf4j\npublic class OrderService {\n    \n    private final OrderRepository orderRepository;\n    private final OutboxService outboxService;\n    private final OrderDomainService orderDomainService;\n    \n    /**\n     * Create order with reliable event publishing\n     */\n    @Transactional\n    public OrderId createOrder(CreateOrderCommand command) {\n        log.info(\"Creating order for customer: {}\", command.getCustomerId());\n        \n        try {\n            // 1. Business logic execution\n            Order order = orderDomainService.createOrder(command);\n            orderRepository.save(order);\n            \n            // 2. Event'leri outbox'a kaydet - AYNI TRANSACTION İÇİNDE!\n            OrderCreatedEvent orderCreatedEvent = OrderCreatedEvent.builder()\n                .orderId(order.getId().getValue())\n                .customerId(order.getCustomerId().getValue())\n                .items(order.getItems().stream()\n                    .map(item -> OrderEventItem.builder()\n                        .productId(item.getProductId().getValue())\n                        .quantity(item.getQuantity())\n                        .unitPrice(item.getUnitPrice().getAmount())\n                        .build())\n                    .collect(Collectors.toList()))\n                .totalAmount(order.getTotalAmount().getAmount())\n                .currency(order.getTotalAmount().getCurrency().getCurrencyCode())\n                .status(order.getStatus().name())\n                .shippingAddress(AddressDto.from(order.getShippingAddress()))\n                .paymentMethod(order.getPaymentMethod())\n                .occurredAt(LocalDateTime.now())\n                .build();\n            \n            // Outbox'a event kaydet\n            outboxService.saveEvent(\n                order.getId().getValue(),\n                \"Order\",\n                orderCreatedEvent\n            );\n            \n            log.info(\"Order created successfully: {}\", order.getId().getValue());\n            return order.getId();\n            \n        } catch (Exception e) {\n            log.error(\"Failed to create order: {}\", command, e);\n            throw new OrderCreationException(\"Order creation failed\", e);\n        }\n    }\n    \n    /**\n     * Update order status with event publishing\n     */\n    @Transactional\n    public void updateOrderStatus(\n        OrderId orderId, \n        OrderStatus newStatus, \n        String reason\n    ) {\n        log.info(\"Updating order status: {} -> {}\", orderId.getValue(), newStatus);\n        \n        Order order = orderRepository.findById(orderId)\n            .orElseThrow(() -> new OrderNotFoundException(orderId));\n        \n        OrderStatus previousStatus = order.getStatus();\n        \n        // Business logic\n        order.updateStatus(newStatus, reason);\n        orderRepository.save(order);\n        \n        // Event to outbox\n        OrderStatusUpdatedEvent statusUpdatedEvent = OrderStatusUpdatedEvent.builder()\n            .orderId(order.getId().getValue())\n            .previousStatus(previousStatus.name())\n            .newStatus(newStatus.name())\n            .reason(reason)\n            .updatedBy(getCurrentUserId()) // Security context'ten\n            .occurredAt(LocalDateTime.now())\n            .build();\n        \n        outboxService.saveEvent(\n            order.getId().getValue(),\n            \"Order\",\n            statusUpdatedEvent\n        );\n        \n        log.info(\"Order status updated: {}\", orderId.getValue());\n    }\n    \n    /**\n     * Cancel order with compensation events\n     */\n    @Transactional\n    public void cancelOrder(OrderId orderId, String reason) {\n        log.info(\"Canceling order: {} - Reason: {}\", orderId.getValue(), reason);\n        \n        Order order = orderRepository.findById(orderId)\n            .orElseThrow(() -> new OrderNotFoundException(orderId));\n        \n        // Validation\n        if (!order.canBeCanceled()) {\n            throw new OrderCancellationException(\n                \"Order cannot be canceled in current status: \" + order.getStatus()\n            );\n        }\n        \n        // Business logic\n        order.cancel(reason);\n        orderRepository.save(order);\n        \n        // Multiple events for different downstream services\n        OrderCanceledEvent orderCanceledEvent = OrderCanceledEvent.builder()\n            .orderId(order.getId().getValue())\n            .customerId(order.getCustomerId().getValue())\n            .reason(reason)\n            .canceledBy(getCurrentUserId())\n            .originalAmount(order.getTotalAmount().getAmount())\n            .currency(order.getTotalAmount().getCurrency().getCurrencyCode())\n            .occurredAt(LocalDateTime.now())\n            .build();\n        \n        PaymentRefundRequestedEvent refundEvent = PaymentRefundRequestedEvent.builder()\n            .orderId(order.getId().getValue())\n            .paymentId(order.getPaymentId().getValue())\n            .refundAmount(order.getTotalAmount().getAmount())\n            .currency(order.getTotalAmount().getCurrency().getCurrencyCode())\n            .reason(\"Order cancellation: \" + reason)\n            .requestedBy(getCurrentUserId())\n            .occurredAt(LocalDateTime.now())\n            .build();\n        \n        InventoryReleaseRequestedEvent inventoryReleaseEvent = \n            InventoryReleaseRequestedEvent.builder()\n                .orderId(order.getId().getValue())\n                .reservationId(order.getInventoryReservationId().getValue())\n                .items(order.getItems().stream()\n                    .map(item -> InventoryReleaseItem.builder()\n                        .productId(item.getProductId().getValue())\n                        .quantity(item.getQuantity())\n                        .build())\n                    .collect(Collectors.toList()))\n                .reason(\"Order cancellation\")\n                .occurredAt(LocalDateTime.now())\n                .build();\n        \n        // Save all events to outbox\n        outboxService.saveEvents(\n            order.getId().getValue(),\n            \"Order\",\n            orderCanceledEvent,\n            refundEvent,\n            inventoryReleaseEvent\n        );\n        \n        log.info(\"Order canceled with events saved to outbox: {}\", orderId.getValue());\n    }\n    \n    private String getCurrentUserId() {\n        // Spring Security context'ten current user'ı al\n        return SecurityContextHolder.getContext()\n            .getAuthentication()\n            .getName();\n    }\n}\n`\n\nBu implementation ile artık **atomik veri yazma ve event publishing** garantisi sağlıyoruz! Database transaction içinde hem business data hem de event'ler kaydediliyor. 🎯\n\n**Sonraki adım:** Message Relay Service implementation'ı! 🚀
